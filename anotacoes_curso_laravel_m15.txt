Oque é uma API?

- Intreface de programação de aplicações;
- Conjunto de rotinas e padrões estabelcido por um sottware para
a untilização das suas funcionalidades por aplicativos que não 
pretendem envolver-se em detalhes da implementação do software,
mas apenas usar seus serviços.
- Web service é tipo de API;
- web service são serviços da internet por meio do protocolo 
http;
- Basicamente temos uma aplicação(cliente) request -> web 
Aplicação(webService) response-> web-> aplicação(cliente);
- API representa uma interface entre dois sistemas quando estamos
no contexto web as api são desenvolvidas por meio dos webservices
que normalmente trabalhando sobre o protocolo HTTP e sua 
comunicação é feita atraves de uma liguagem universal geralmente
XML ou JSON;
_________________________________________________________________
Entendendo os princípios do REST

- Tranferencia representacional de estado;
- A principio surgiu apenas para melhorar as falhas que o HTTP
tinha;
- O REST não foi pensado para web services ele foi pensando para
melhorar a semântica do protocolo HTTP;
_________________________________________________________________
Iniciando o projeto Locadora de Carros

php artisan make:model --migration --controller --resource Marca

- Utilizamos esse comando para criar as migrations os controllers;

php artisan make:model -mcr  Modelo

- Com esse comando criamos tudo denovo porem com abreviação das
palavras;

php artisan make:model --all Carro 

- Já com esse comnado criamos tudo que os outros dois comando 
criou acrescido do seeder e do factory;

- Criamos tudo para Cliente e Locacao;
_________________________________________________________________
Configurando a conexão com o banco de dados e implementando as 
migrations

- Baixe o arquivo zip das migrations na pasta banco de dados;
- Não se esqueça de alterar o Locacaos para Locacoes e trocar 
tudo que possa estar errado nesse sentindo;
- Em locacao.php foi adicionado 

protected  $table ='locacoes';

- Além de ter realizado as outras alterações necessárias;
- Após realizar alterações envie para o banco de dados com o 
comando;

php artisan migrate;
_________________________________________________________________
Entendendo o grupo de rotas Web e API e a importância do 
Content-Type

- O content-type é responsavel por entregar ao cliente a resposta
em text/html que é o mais comum geralmente ou em application/json;
- Dicionando isso;

Route::get('/', function () {
    return ['chegamos até aqui'=>'sim'];
});

- E colocando em inspecionar na tela em http://127.0.0.1:8000/api
em network > api > response > content-type > Você consegue 
visualizar qual a extensão do arquivo sé json ou html;
_________________________________________________________________
Rotas e a diferença entre Route::resource e Route::apiResource

- A difrença entre eles é o mapeamento das rotas de modo 
automatico do metodo create e edit;
- Portanto quando trabalharmos com api utilizaremos o apiResource

Route::apiResource('cliente', 'App\Http\Controllers\ClienteController');

- Com isso podemos remover da nosaa class o metodo edit e metodo 
create;
- Crie uma rota api resource para cada controlador criado;
_________________________________________________________________
Extra (fix da aula anterior) - Atributo $namespace de 
RouteServiceProvide

- Ensinando como ajustar o comportamento de não precisar passar a
rota inteira do Controller;
- No laravel 8 vc tem que ir no diretorio Providers > 
RouteServiceProvider.php e descomantar a linha que fala sobre o
controller;
- Mas é indicado para vc que esta iniciando coloque o namespace
completo como haviamos feito;
_________________________________________________________________
Criando registros via POST

- php artisan route:list

- Com esse comando consigo tem acesso a todas routas que foram 
criadas e atraves disso vamos trabalhar com a rota api/marca cujo
o metodo seja posto que chama marca.store;
- Em marcaController adicione uma linha de comanda de return para
ser visual apenas como um teste;
- Em seguida abra o software POSTMAN que te auxiliará na 
manipulação da api;
- Crie um novo buscador de api - adicione o metodo post - em 
seguida direcione qual é a rota que ela deve pesquisar;

localhost:8000/api/marca;

- E clique em Send para verificar se ela esta tendo retorno;
- No POSTMAN vai até body e nele por enquando deixe o 
form-urlencoded;
- Acresente nome e imagem e qualquer valor voltado para teste 
apricncipio adicionei nome-> toyota e imagem -> imagem_toyota.png;
- Em seguida no Controller foi adicionado um dd($request); e no
POSTMAN clicamos em send e em seguida em preview para visualizar
se realmente estavamos tendo uma comunicação e resposta;
- No controller coloque;

Marca::create($request->all());

- Para ser possivel a inserção no banco de dados, porém temos que
na Model Marca e colocar o $fillable passando os paramentros que
vão ser aceitos;

protected $fillable = ['nome','imagem'];

- Em seguida clique em send e veja seu banco de dados;
_________________________________________________________________
Selecionando registros via GET

- Vamos manipular agora dois novos end.points para consulta dos 
registros do tipo marca sendo um geral e um especifico;
- A rota marca.index é resposavel por todos os registros já a 
marca.show é responsavel por um registro especifico;
- No MarcaController;

$marcas = Marca::all();
return $marcas;

- No POSTMAN adicione a rota da api com o metodo GET;

localhost:8000/api/marca;

- Em seguida teste e veja todos os arquivos que foram solicitados;
- Para marca.show;

return $marca;
echo'Chegamos até aqui (show)';

- No POSTMAN adicione a rota com o parametro necessario exemplo
do id escolhi o id de numero 1

localhost:8000/api/marca/1; 

- Teste e veja, em seguida troque o id;
_________________________________________________________________
Atualizando registros via PUT e PATCH

- Vamos implementra um novo end.point na nossa api webservice 
que sera possivel atualizar um registro do tipo marca;
- Para ser possivel esse update é necessario no postman passar o
identificador unico, também passar o verbo http no caso PUT por
enquanto;

print_r($request->all());//os dados atualizados
echo '<hr>';
print_r($marca->getAttributes());//os dados antigos
$marca->update($request->all());
return $marca;

- Agora o PATCH em relação ao PUT não tem nenhuma diferença pois
os dois são utilizados para a mesma finalizada porém 
semanticamente é esperado que patch faz parte de pequenas 
atualizações não atualizações completas;
- Pegamos nosso exemplo seria ideal que utiliza-se apenas para 
alterar o nome, não todos os dados;
_________________________________________________________________
Removendo registros via DELETE

- Também é necessario que você passe o parametro na url;
 
$marca->delete($marca);
return ['msg'=>'A marca foi deletado'];
_________________________________________________________________
Extra - Entendendo o conceito de endpoint (URL, URN e URI)

- URL -> Host onde esta o recurso
jorgesantana.com
google.com

- URN -> Recurso dentro do host

/api/vagas
/curso/curso-completo-do-desencolvedor-laravel

- URI -> Combinação do protocolo + URL + URN
https://udemy.com/curso/curso-completo-do-desencolvedor-laravel
https://jorgesantana.com/api/vagas
_________________________________________________________________
Injetando a instância do Model no Controller e como lidar com 
o Type Hinting

- Estamos basicamento manipulando nossos model atraves de dois 
jeito um sendo estatico e outro seugestão do tipo 
- No estatico não estamos intanciando objetos estamos apenas 
utilizando uma função interna;
- Já no sugestão de tipo precisamos estanciar o objeto ou muitas
vezes o laravel já realiza issso para você e você só precisa 
chama-lo;
- Tmabém é possivel realizar isso com um outro metodo no caso 
sendo injeção do model que no caso instaciamos ele no construtor
do nosso controller;

protected $marca;

    public function __construct(Marca $marca)
    {
        $this->marca = $marca;
    }
----------------------------------------------
public function index()
    {
        //$marcas = Marca::all();
        $marca = $this->marca->all();
        return $marca;
    }
-----------------------------------------------
public function store(Request $request)
    {
        //$marca = Marca::create($request->all());
        $marca = $this->marca->create($request->all());
        return $marca;
    }
-----------------------------------------------
public function show( $id)
    {
        $marca = $this->marca->find($id);
        return $marca;
    }
-----------------------------------------------
public function update(Request $request, $id)
    {
        // print_r($request->all());//os dados atualizados
        // echo '<hr>';
        // print_r($marca->getAttributes());//os dados antigos

        $marca = $this->marca->find($id);
        $marca->update($request->all());
        return $marca;
    }
-----------------------------------------------
public function destroy($id)
    {
       $marca = $this->marca->find($id);
       $marca->delete();
       return ['msg'=>'A marca foi deletado'];
    }
_________________________________________________________________
Validações parte 1 - Controle de fluxos

- Vamos focar por enquanto no show, update e destrpy, caso eles 
não tenham recurso retornar json com mensagem de indiponivel

public function destroy($id)
    {
       $marca = $this->marca->find($id);
       if ($marca === null) {
        return ['erro'=>'Recurso indisponivel - (Exclusão)'];
    }
       $marca->delete();
       return ['msg'=>'A marca foi removida'];
    }
_________________________________________________________________
Validações parte 2 - Status Code HTTP

- Status code e como podemos aplicalos dentro da nossa api.
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
- Esse link tem como objetivo mostrar todo os status code do 
protocolo HTTP;
- Perceba que o Status Code é muito importante porque estamos 
fazendo uma requisição de caso ele não encontre o valor ele 
retorna;


return ['erro'=>'Recurso indisponivel - (Atualização)'];


- Porém se olharmos para o Status code ele vai indicar status 
200 que é um status de sucesso na resposta porém não foi 
encontrado oque vc queria;
- Com isso o mais indicado é vc modificar a nomenclatura 
indicando o erro real e não o status code errado para aquela 
resposta da requisição;


return response()->json(['erro'=>'Recurso indisponivel - 
(ver id)'], 404);

- No caso do store também adicionamos ;

$marca = $this->marca->create($request->all());
return response()->json($marca, 201);

- Teste no seu POSTMAN essas validações que fizemos e veja como
é importante cada validação;
_________________________________________________________________
Validações parte 3 - Validando parâmetros e a importância do 
Accept

- Iremos tratar o metodo store de como em que caso o parametro 
não seja válido retorna um json com as mensagens de feedback(s);


//tratar nome e imagem
 $regras = ['nome' => 'required|unique:marcas',
        'imagem'=> 'required'
    ];
 $feedback = [
        'required'=> 'O campo :attribute é obrigatório.',
        'nome.unique' => 'O nome da marca já existe.'
    ];
  $request ->validate($regras, $feedback);


- Para essa validação acontecer e não encaminhar o cliente de 
volta uma página inicial como o validade trabalha o ideal é vc no 
header do postman colocar o Accept pois vc esta dizendo que esse 
cliente consegue trabalhar com arquivos json;
_________________________________________________________________
Implementando as regras de validação (Rules) no Model

- A regra que criamos anteriormente funciona porém ela fica muito
sucetivel a erro, um exemplo disso e caso marca receba um 
atributo isso já pode gerar um problema para nós futuramente;
- Então o ideal é você colocar esse tipo de validação dentro do 
model marca por uma vez que alterado isso implica em tudo de 
uma vez;
- Criamos 2 metodos dentro da model;

public function rules() {
        return [
        'nome' => 'required|unique:marcas',
        'imagem'=> 'required'
    ];

    }
    public function feedback(){
        return [
        'required'=> 'O campo :attribute é obrigatório.',
        'nome.unique' => 'O nome da marca já existe.'
        ];
    }

- Em seguida no Controller adicionamos;

$request ->validate($this->marca->rules(),$this->marca->feedback());

- Estamos validando a requisição onde atraves da model marca 
estamos chamando o metodo rules e feedback para realizar essa
validação;
_________________________________________________________________
Validações parte 4 - Regras de validação no Update - Lidando 
com o Unique

- A validação unique lea tem três parametros;

1- tabela;
2- nome da coluna que será pesquisda na tabela;
3- id do registro que sera desconsiderado na pesquisa;

'nome' => 'required|unique:marcas,nome,'.$this->id.'|min:3',

- No caso fizemos uma validação no controller de modo em que todo
update vai precisar acessar o usuario que já existe e realizar 
uma alteração em algo. Resumindo, essa validação assegura que o 
campo nome seja obrigatório, único na tabela marcas (com exceção 
do registro atual durante a atualização) e tenha pelo menos 3 
caracteres de comprimento;
_________________________________________________________________
Validações parte 5 - Regras de validação no Update - Lidando 
com o PUT/PATCH

- Criamos dentro do update uma validação capaz de aceitar tanto
o PATCH quanto o PUT
- No controller 

}
        if($request->method() === 'PATCH'){

            $regrasDinamicas =array();

            //percorrendo todas as regras definidas no modo
            foreach($marca->rules() as $input => $regra){

                //coletar apenas as regras aplicasveis aos paramêtros parciais da requisição PATCH
                if (array_key_exists($input, $request->all())) {
                    $regrasDinamicas[$input] = $regra;
                }
            }

            $request->validate($regrasDinamicas, $marca->feedback());
        }

        else{
        $request->validate($marca->rules(), $marca->feedback());
        }

        $marca->update($request->all());
        return response()->json($marca, 200);
    }
_________________________________________________________________
Upload de arquivos - Implementando o upload de imagens parte 1

- Como realizar upload de arquivos no caso vamos utilizar upload
de imagem mas pode ser usado para vídeo, som e etc ...
- Agora dentro do post vamos trabalhar com outro parametro no 
body vamos trabalhar com form_data iremos por enquando dizer que
nosso cliente sabe trabalhar com arquivos json e utilizaremos
o metodo post (store).
- Podemos acessar os arquivos texte e file dessa forma;

       //dd($request->nome);
       //dd($request->get('nome'));


       //dd($request->file('imagem'));
       //dd($request->imagem);
_________________________________________________________________
Upload de arquivos - Implementando o upload de imagens parte 2

- Para realizar o upload de um arquivo precisamos passar dois 
parametros para ele um é o caminho e outro o disco é onde ele vai
ficar;

	$image = $request -> file('imagem');
        //$image ->store('path','disco');
	$image ->store('imagens', 'local');

- Por padrão vem no disco local do nossa aplicação mas se 
quisermos também podemos definir para ser baixadas na pasta 
public e etc..
_________________________________________________________________
Upload de arquivos - Implementando o upload de imagens parte 3

- Chegou a hora de implementarmos a lógica para recuperamos o 
nome eo patch de onde está esse arquivo para conseguirmoa acessar;
- Também vamos tratar o tipo de arquivo recebido;
- Na model;

'imagem' => 'required|file|mimes:png';

- Adicionamos file e mimes e em seguida podemos adicionar arquivos
de diversas extensões como xlss, ppt, pdf, jpeg, mp3, mp4;

- No Controller;

 $imagem = $request -> file('imagem');
       $imagem_urn = $imagem ->store('imagens', 'public');

       $marca =$this->marca->create([
        'nome' => $request->nome,
        'imagem' => $imagem_urn
       ]);
_________________________________________________________________
Upload de arquivos - Criando um link simbólico para o disco 
public

- Iremos criar um link simbolico para /public pois ele é o unico
diretorio publico dentro do laravel;

php artisan storage:link 
ou 
php artisan storage:link --force

- Em seu terminal coloque esse comando e ele será responsável 
por gerar um link desse tipo que precisamos;
- Lembre-se esse diretorio trabalha em conjunto com storage/app
/public/imagens caso vc exclua algo em um no outro também 
ocorrerá e isso é para tudo;
- Com isso craido eu consigo acessar essas imagens atraves de 
uma requisição get por exemplo;
- Coloque ele link no seu POSTMAN com o metodo get, lembre-se 
colocar o direcionamento de uma imagem válida do seu sistema;

localhost:8000/storage/imagens/6w1e44KVT0CwuPBB6cBGsZbQSW7y
QRKTr0qifEQ5.png
_________________________________________________________________
Upload de arquivos - Atualizando imagens

- Para ser possível atualizar o arquivo com imagem temos que 
utilizar um _metodo com pararmetro put ou patch no nosso POSTMAN
dessa forma; 

_method na key
put no value

- Assim como nome e bmw;
- Isso é um alimitação do framework laravel por isso temos que 
fazer isso;
_________________________________________________________________
Upload de arquivos - Removendo imagens

- Teremos a remoção da imagem em dois momentos, um momento quando 
atualizarmos teremos que remover a imagem antiga, e quando for 
feito o delete;
- Para realizar essa exclusão montamos uma condição para isso no 
update;

if ($request->file('imagem')) {
        Storage::disk('public')->delete($marca->imagem);
    }

- Onde vai a requisição de arquivos do tipo imagem vai até public
e exclui da marca a imagem já existente para a adição da nova;
- Agora no destroy;

  Storage::disk('public')->delete($marca->imagem);
________________________________________________________________
API WebService Rest para o Resource Modelo

- Estamos instanciando o metodo rules na model modelo e 
adicionando novos atributos;

public function rules()
    {
        return [
            'marca_id' =>'exists:marcas,id',
            'nome' => 'required|unique:modleos,nome,' . $this->id . '|min:3',
            'imagem' => 'required|file|mimes:png, jpg,jpeg',
            'numero_portas'=> 'required|integer|digits_between:1,5',//1 a 5
            'lugares'=> 'required|integer|digits_between:1,20',//1 a 20
            'air_bag'=>'required|boolean',
            'abs'=>'required|boolean' // true, flase, 1, 0, '1', '0'
        ];
    }

- Em seguida no controller iremos colocar a lógica de todos os 
metodos que temos como index, store, show, update e destroy;
- Basicamente é a mesma lócia do controller marca claro que com
as mudanças de chama do construtor modelo os atributos dele, 
acresido de uma nova pasta para $imagem_urn;

$imagem_urn = $imagem ->store('imagens/modelos', 'public');

- No metdod update e store;
_________________________________________________________________
Testando os endpoints de modelo

- Caso esteja com algum erro olhe na model modelos em rules em 
nome provavelmente a palavra modelos pode estar errada, e logo 
a cima também em protected $fillable a palavra imagens;
- Testamos com sucesso a aplicação dos metodos na pratica e com
isso foi constado que apenas o metodo PATCH precisa ser revisto
uma vez que não esta de acordo com o ModeloController mais;
_________________________________________________________________
Adicionando o relacionamento entre modelos e marcas

- Para adicionar o relacionamneto é bem simples criamos dois 
metodos um em cada model sendo ela marca e modelo instaciando 
nelas que uma marca tem diversos modelo e um modelo tem uma marca;
- Em modelocontroller foi adicionado uma expressão de 
relacionamento da controler modelo para com marca no metodo 
store da seguinte forma;

$modelo = $this->modelo->with('marca')->find($id);

- Sendo a expressão with('marca');
- No metodo index também adicionamos um with() pois quando 
pesquisarmos por modelo iremos ter o retorno também da marca;

return response()->json( $this->modelo->with('marca')->get(), 200);

- Também foi preciso alterar o metodo que antes era all() e agora
passou a ser get() pois com o all() poderia gerar alguns erros no
nosso código por conta do funcionamento do all();
_________________________________________________________________
Refactoring do endpoint update de marca e modelo

- Criamos um novo jeito de atualização com patch pois desse modo
conseguimos atualizar de forma que não modefique algo já 
existente;

$marca->fill($request->all());
$marca->imagem = $imagem_urn;
$marca->save();
_________________________________________________________________
Filtros - Selecionando os atributos de retorno

- Vamos desenvolver algo voltado para uma pesquisa onde você pode
selecionar qual atributo vc quer buscar dos registros que temos;
- Com isso nosso index foi modificado e ficou assim;

public function index(Request $request)
    {
        $modelos= array();

        if($request->has('atributos')){
            $atributos= $request->atributos;
            $modelos = $this->modelo->selectRaw($atributos)->with('marca')->get();

        }else{
            $modelos = $this->modelo->with('marca')->get();
        }
        return response()->json($modelos, 200);

        //all() -> craindo um obj de consulta +get() =collection
        //get() -> modedificar a consulta -> colletion
    }
_________________________________________________________________
Filtros - Obtendo colunas específicas com a instrução with()

- Agora vai ser criado um jeito de buscarmos algum parametro do 
objeto que esta relacionado com o with();

 public function index(Request $request)
    {
        $modelos = array();

        if($request->has('atributos_marca')) {
            $atributos_marca = $request->atributos_marca;
            $modelos = $this->modelo->with('marca:id,'.$atributos_marca);
        } else {
            $modelos = $this->modelo->with('marca');
        }

        if($request->has('atributos')) {
            $atributos = $request->atributos;
            $modelos = $modelos->selectRaw($atributos)->get();
        } else {
            $modelos = $modelos->get();
        }

        //$this->modelo->with('marca')->get()
        return response()->json($modelos, 200);
        //all() -> criando um obj de consulta + get() = collection
        //get() -> modificar a consulta -> collection
    }

_________________________________________________________________
Filtros - Aplicando condições nas pesquisas parte 1

- Vamos implementar uma lógica que vai permitir ao cliente ter 
uma opção de pesquisa;

if ($request ->has('filtro')) {
$filtro = explode(':',$request->filtro);
$modelos = $modelos->where($filtro[0],$filtro[1],$filtro[2]);

        }
_________________________________________________________________
Filtros - Aplicando condições nas pesquisas parte 2

- Aplicamos uma condição de pesquisa onde o cliente consegue 
pesquisar por diversos parametros;

if ($request->has('filtro')) {

$filtro = explode(';', $request->filtro);
foreach ($filtro as $key => $condicao) {
$c = explode(':', $condicao);
$modelos = $modelos->where($c[0], $c[1], $c[2]);
            }
        }
_________________________________________________________________
Filtros - Aplicando os filtros ao resource Marca

- Aplicarmos os parametros que realizamos de filtro de modelo 
para marcas onde funcionou perfeitamente;
- Não esqueça de colocar o pametro Request $request no index;
_________________________________________________________________
Repository Design Pattern - Introdução

- É uma solução geral para um problema que ocorre com frequencia 
dentro de um contexto;
- Surgindo as boas práticas;
- Se olharmos para o contexto da programação orientada a objetos 
estamos ferindo-a pois em alguns contextos estamos relizando a 
aplicação código semelhantes;
- Oque iremos realizar por agora é ao invés do controller 
manipular um model ele manipule um repositorio eo repositorio 
uma model;
_________________________________________________________________
Repository Design Pattern - Implementando um Repository para 
Marca

- Vamos criar um repositorio para marca;
- Em app crei um pasta Repositories > e um arquivo 
MarcaRepository.php;
- Nesse repositorio instaciamos diversas funções para conseguirmos
desfrutar doque é desing pattern e com isso evitar a repetição de
códigos;
__________________________________________________________________
Repository Design Pattern - Implementando um Repository para 
Modelo

- Impletaremos nessa etapa o repositorio para modelo;
- Basicamente ele é um ctrl+c ctrl+v de tudo que fizemos no 
marcaRepository e com isso realizamos apenas as modificações que 
eram necessario para funcionar no POSTMAN;
__________________________________________________________________
Repository Design Pattern - Implementando um Abstract Repository

- Nessa etapa iremos criar uma nova class onde iremos armazenar 
todo tipo de código comum desses dois repositorio criados 
anteriormente;
- Coloque toda informação contida nessas duas classes em abstract
pois iremos centralizar nela tudo que seja comum em outras classes;
e nas proprias classe deixaremos apenas oque é especifico de cada
uma; 
__________________________________________________________________
API WebService Rest para o Resource Carro

- Nessa etapa iremos basicamente realizar ctrl+c ctrl+v para o 
carrocontroller de modo em que seja possível termos como alvança 
dentro da nossa API;
- Criamos CarroRepository, Codificamos a model Carro e também
CarroController;
__________________________________________________________________
API WebService Rest para o Resource Cliente

- Nessa etapa iremos basicamente realizar ctrl+c ctrl+v para o 
clientecontroller de modo em que seja possível termos como alvança 
dentro da nossa API;
- Criamos ClienteRepository, Codificamos a model Cliente e também
ClienteController;
__________________________________________________________________
API WebService Rest para o Resource Locacoes

- Nessa etapa iremos basicamente realizar ctrl+c ctrl+v para o 
Locacoescontroller de modo em que seja possível termos como 
alvança dentro da nossa API;
- Criamos LocacoesRepository, Codificamos a model Locacoes e 
também LocacoesController;
__________________________________________________________________
Introdução ao JWT (Json Web Token)

- Autenticação por usuario e senha e autorização por meiode tokem
em API WebService Rest;
- Basicamente o cliente faz uma requisição para logar e com isso 
essa requisição parte para API onde ela realiza a autenticação e 
gera um token de autorização onde é armazendo no BD em seguida
retorna o token de autorização para o cliente;
- O JWT é contituido por três partes pelo header/polyload/
signature;
- Na pratica o token é a autorização e precisa estar presente em 
todas requisições feitar pelo cleinte;
__________________________________________________________________
Instalando o pacote JWT-Auth
 
- No seu terminal, na pasta do projeto coloque esse comando

composer require tymon/jwt-auth
__________________________________________________________________
Configurando o JWT-Auth no projeto

- Esse link vai ser capaz de te ajudar com a configuração

https://medium.com/@demian.kostelny/install-jwt-in-laravel-app-2023-guide-for-beginners-94f7245ce6bd

__________________________________________________________________
Implementando a interface JWTSubject no model User e o Auth Guard
API Driver JWT

- Em quick star será possivel te ajudar;

https://medium.com/@demian.kostelny/install-jwt-in-laravel-app-2023-guide-for-beginners-94f7245ce6bd
__________________________________________________________________
Criando as rotas de autenticação e autorização e o AuthController

- Criaremos algumas rota e também um controller para conseguirmos 
dar andamento nesse tema;

php artisan make:controller AuthController 

- Implemente no Authcontroller return mais o nome do metodo para
 teste no postman;
__________________________________________________________________
Inserindo um usuário no banco de dados

- Traves do tinker inserimos um usuario no banco de dados;

php artisan tinker;

$user =  new App\Models\User();

$user->name ="Jorge"

$user->email = 'jorge@teste.com'

$user->password = bcrypt('1234')

$user->save()
__________________________________________________________________
Implementando o método de login (autenticação) e o JWT 
(autorização)

- Iremos estilizar o metodo login onde terremos a autenticação eo 
retorno de um tokem jwt;
- Realizamos a validação o auth selecionando a tipo api para 
retornar um token;
- Implementamos também um if else para validar usuario autenticado
ou não;
__________________________________________________________________
Configurando rotas protegidas por autorização

- Nessa etapa realizamos a craiação de um grupode rotas onde eles 
estão protegidos através do middleware jwt.auth no caso voltado
para autenticação ou sejá só vai ser realizado a interação com 
aquela rota caso tenha autenticação;

Route::middleware(['jwt.auth'])->group(function () { //Grupo de proteção com autenticação do usuário
    // Rotas protegidas aqui
    Route::apiResource('cliente', ClienteController::class);
    Route::apiResource('carro', CarroController::class);
    Route::apiResource('locacao', LocacaoController::class);
    Route::apiResource('marca', MarcaController::class);
    Route::apiResource('modelo', ModeloController::class);
});

__________________________________________________________________
Criando um grupo de rotas protegidas com um prefix de 
versionamento

- Dentro do grupo de rotas já criado colocamos um prefix onde é 
possível realizar um versionamento atraves dele porém agora é 
necessário passar esse parametro do prefix na url;

Route::prefix('v1')->middleware(['jwt.auth'])->group(function () {
__________________________________________________________________
Enviando o JWT de autorização nas requisições (Authorization 
Bearer)

- Agora vamos entender como é possível armazenar o o token ao 
cliente para requisições futuras;
- Para realizarmos isso é necessario no postman na parte do headers
onde constumamos colocar aceppt e apliocation/json adicionarmos
mais um campo a chave key Authorization e no value adiconar o token
que temos da aplicação quando válida e no inicio do token adicionar

Bearer e um espaço;

- Ficando assim;

Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG
9jYWxob3N0OjgwMDAvYXBpL2xvZ2luIiwiaWF0IjoxNzEzODgwNzIwLCJleHAiOjE
3MTM4ODQzMjAsIm5iZiI6MTcxMzg4MDcyMCwianRpIjoiaWx2VVJMMTRHUmJtbnRL
RSIsInN1YiI6IjEiLCJwcnYiOiIyM2JkNWM4OTQ5ZjYwMGFkYjM5ZTcwMWM0MDA4N
zJkYjdhNTk3NmY3In0.IU-gVbdYgTGPSLScbb1tDWvTHA83C-jfsdgbE9OBRDI

- Com isso você tera acesso a todas as rotas;
__________________________________________________________________
Recuperando os dados do usuário autenticado com base no JWT

- Com base no token do usuario é possivel realizar pegarmos dados
do mesmo;
- Foi necessário colocar a rota me dentro do grupo de rotas com 
autenticação;
- Dentro do metodo me codamos para retornar dados menos sensiveis 
do usuario;
__________________________________________________________________
Atualizando o JWT (renovando a autorização)

- Iremos aprender como atualizar o jwt;
- Mais para frente aprederemos também como é possível configurar
um token para um determinado tempo de uso;

$token = JWTAuth::getToken();
$refreshedToken = JWTAuth::refresh($token); // Tente atualizar o token
return response()->json(['token' => $refreshedToken]); // Retornar o novo token JWT
__________________________________________________________________
Invalidando o JWT (revogando a autorização)

- Iremos instaciar o metodo logout que é resposavel por invalidar 
o token ou seja deixa ele invalido dentro da blacklist;

public function logout()
    {
        auth('api')->logout();
        return response()->json(['message' => 'Logout realizado com sucesso']);
    }

- coloque no paremtro da url tudo que necessario;

POST - localhost:8000/api/v1/logout

accept -> application/json
authorization ->Bearer <token>;
__________________________________________________________________
Anatomia do JWT (Json Web Token)

- Agora vamos aprender um pouco sobre a anatomia do jwt
- Ele é dividido em trÊs partes e é isso que vamos ver nesse site;
- Em jwt.io coloque um token de sua preferencia;
- Descesndo até DEBUG coloque seu token e repare que ele tem tres
cores;
- header/payload/verify-signature;
- Para ele se tornar valído ele precisa da senha que esta no .env;
__________________________________________________________________
Expirando o JWT por tempo limite

- Gere o token e coloque em jwt.io 
- Temos dois campos dentro do payload o IAT ->data de geração do 
token e EXP ->data de encimento do token;
- Em config>jwt.php> procure por 'ttl';
- Lá esta a instrução do sobre tempo;
- Troque pelo valor em que o tempo seja de sua preferencia;
__________________________________________________________________
Configurando o Vue.JS no Laravel

- Primeiro instalaremos algumas coisas para o nosso projeto 
funcionar de forma integra;

composer require laravel/ui

- Gerar esqueleto do projeto com Vue.JS e autenticação web nativa
 (scaffold/esqueleto)

php artisan ui vue --auth

- Baixar as dependencias de front-end

npm install

- Produzindo o bundle de front-end

npm run dev 
__________________________________________________________________
Convertendo a view login em um componente Vue

- Criamos um novo arquivo em components e atraves do 
login.blade.php estilezamos ele, claro retirando todas as menções
ao PHP;
__________________________________________________________________
Gerando o build da aplicação front com o npm run watch

- No laravel 11 não precisamos realizar esse comando porém nas 
versões anteriores sim;
__________________________________________________________________
Vue Props - Encaminhando o token csrf para o componente Login

- Criamos uma parametro dentro do Login com o csrf;
__________________________________________________________________
Implementando a autenticação web (sessão) e API (JWT)

- Na tela login.vue implementamos aalgumas lógicas autenticação 
para um login em conjunto com a nossa API com JWT;


<script>
export default {
    props: ['csrf_token'],
    data() {
        return {
            email: '',
            password: ''
        }
    },
    methods: {
        login(e) {
            let url = 'http://localhost:8000/api/login';
            let configuracao = {
                method: 'post',
                body: new URLSearchParams({
                    'email': this.email,
                    'password': this.password,
                })
            };
            fetch(url, configuracao) // o fetch resonsavel por pegar as informções que vc precisa
                .then(response => response.json()) //tranformando em json
                .then(data => {
                    console.log(data.token) //aqui temos o token de forma isolada
                    if (data.token) {
                        document.cookie = 'token=' + data.token + ';SameSite=Lax'//(nome/puxando o token recuperado/parametro para HTTP) Essa intrução vai permitir que os cookies sejam encaminhados por padrão nas requisições HTTP
                    }
                    e.target.submit()//dar sequencia no envio do form de autenticação por sessão
                })
        }
    }
}
</script>
__________________________________________________________________
Convertendo a view home em um componente Vue

- Instaciamos a tela home e com isso temos já duas telas no nosso 
app;
- Lembre-se coloca-la no app.js assim como login, também de chama-lá
em home.blade.php e instacia-lá em home.vue;
__________________________________________________________________
Criando o menu de navegação da aplicação

- Aplicamos um menu dentro do app também colocamos uma 
autenticação que aquilo só vai aperecer caso o cliente esteja 
logado;
__________________________________________________________________
Criando a rota, a view e o componente marcas

- Criamos na rotas em routes->web.php em seguida criamos ela em
marcas.vue, depois adicionamos em app.js, depois criamos um diretorio
em views com nome app e depois um aquivo marcas.blade.php e chamamos
a view marcas;
__________________________________________________________________
Criando o card de busca de registros

- Criamos o car de busca com boostrap para facilitar a craição do 
front nessa etapa e vai ser assim até o final do projeto;
- Estilizamos dentro de Marcas.vue;
__________________________________________________________________
Criando um componente Vue para encapsular inputs

- Instaciamos um tipo de componente voltado para o vue onde podemos
utilizalo agora quando quisermos de modo mais facil para futuros
inputs;
__________________________________________________________________
