Oque é uma API?

- Intreface de programação de aplicações;
- Conjunto de rotinas e padrões estabelcido por um sottware para
a untilização das suas funcionalidades por aplicativos que não 
pretendem envolver-se em detalhes da implementação do software,
mas apenas usar seus serviços.
- Web service é tipo de API;
- web service são serviços da internet por meio do protocolo 
http;
- Basicamente temos uma aplicação(cliente) request -> web 
Aplicação(webService) response-> web-> aplicação(cliente);
- API representa uma interface entre dois sistemas quando estamos
no contexto web as api são desenvolvidas por meio dos webservices
que normalmente trabalhando sobre o protocolo HTTP e sua 
comunicação é feita atraves de uma liguagem universal geralmente
XML ou JSON;
_________________________________________________________________
Entendendo os princípios do REST

- Tranferencia representacional de estado;
- A principio surgiu apenas para melhorar as falhas que o HTTP
tinha;
- O REST não foi pensado para web services ele foi pensando para
melhorar a semântica do protocolo HTTP;
_________________________________________________________________
Iniciando o projeto Locadora de Carros

php artisan make:model --migration --controller --resource Marca

- Utilizamos esse comando para criar as migrations os controllers;

php artisan make:model -mcr  Modelo

- Com esse comando criamos tudo denovo porem com abreviação das
palavras;

php artisan make:model --all Carro 

- Já com esse comnado criamos tudo que os outros dois comando 
criou acrescido do seeder e do factory;

- Criamos tudo para Cliente e Locacao;
_________________________________________________________________
Configurando a conexão com o banco de dados e implementando as 
migrations

- Baixe o arquivo zip das migrations na pasta banco de dados;
- Não se esqueça de alterar o Locacaos para Locacoes e trocar 
tudo que possa estar errado nesse sentindo;
- Em locacao.php foi adicionado 

protected  $table ='locacoes';

- Além de ter realizado as outras alterações necessárias;
- Após realizar alterações envie para o banco de dados com o 
comando;

php artisan migrate;
_________________________________________________________________
Entendendo o grupo de rotas Web e API e a importância do 
Content-Type

- O content-type é responsavel por entregar ao cliente a resposta
em text/html que é o mais comum geralmente ou em application/json;
- Dicionando isso;

Route::get('/', function () {
    return ['chegamos até aqui'=>'sim'];
});

- E colocando em inspecionar na tela em http://127.0.0.1:8000/api
em network > api > response > content-type > Você consegue 
visualizar qual a extensão do arquivo sé json ou html;
_________________________________________________________________
Rotas e a diferença entre Route::resource e Route::apiResource

- A difrença entre eles é o mapeamento das rotas de modo 
automatico do metodo create e edit;
- Portanto quando trabalharmos com api utilizaremos o apiResource

Route::apiResource('cliente', 'App\Http\Controllers\ClienteController');

- Com isso podemos remover da nosaa class o metodo edit e metodo 
create;
- Crie uma rota api resource para cada controlador criado;
_________________________________________________________________
Extra (fix da aula anterior) - Atributo $namespace de 
RouteServiceProvide

- Ensinando como ajustar o comportamento de não precisar passar a
rota inteira do Controller;
- No laravel 8 vc tem que ir no diretorio Providers > 
RouteServiceProvider.php e descomantar a linha que fala sobre o
controller;
- Mas é indicado para vc que esta iniciando coloque o namespace
completo como haviamos feito;
_________________________________________________________________
Criando registros via POST

- php artisan route:list

- Com esse comando consigo tem acesso a todas routas que foram 
criadas e atraves disso vamos trabalhar com a rota api/marca cujo
o metodo seja posto que chama marca.store;
- Em marcaController adicione uma linha de comanda de return para
ser visual apenas como um teste;
- Em seguida abra o software POSTMAN que te auxiliará na 
manipulação da api;
- Crie um novo buscador de api - adicione o metodo post - em 
seguida direcione qual é a rota que ela deve pesquisar;

localhost:8000/api/marca;

- E clique em Send para verificar se ela esta tendo retorno;
- No POSTMAN vai até body e nele por enquando deixe o 
form-urlencoded;
- Acresente nome e imagem e qualquer valor voltado para teste 
apricncipio adicionei nome-> toyota e imagem -> imagem_toyota.png;
- Em seguida no Controller foi adicionado um dd($request); e no
POSTMAN clicamos em send e em seguida em preview para visualizar
se realmente estavamos tendo uma comunicação e resposta;
- No controller coloque;

Marca::create($request->all());

- Para ser possivel a inserção no banco de dados, porém temos que
na Model Marca e colocar o $fillable passando os paramentros que
vão ser aceitos;

protected $fillable = ['nome','imagem'];

- Em seguida clique em send e veja seu banco de dados;
_________________________________________________________________
Selecionando registros via GET

- Vamos manipular agora dois novos end.points para consulta dos 
registros do tipo marca sendo um geral e um especifico;
- A rota marca.index é resposavel por todos os registros já a 
marca.show é responsavel por um registro especifico;
- No MarcaController;

$marcas = Marca::all();
return $marcas;

- No POSTMAN adicione a rota da api com o metodo GET;

localhost:8000/api/marca;

- Em seguida teste e veja todos os arquivos que foram solicitados;
- Para marca.show;

return $marca;
echo'Chegamos até aqui (show)';

- No POSTMAN adicione a rota com o parametro necessario exemplo
do id escolhi o id de numero 1

localhost:8000/api/marca/1; 

- Teste e veja, em seguida troque o id;
_________________________________________________________________
Atualizando registros via PUT e PATCH

- Vamos implementra um novo end.point na nossa api webservice 
que sera possivel atualizar um registro do tipo marca;
- Para ser possivel esse update é necessario no postman passar o
identificador unico, também passar o verbo http no caso PUT por
enquanto;

print_r($request->all());//os dados atualizados
echo '<hr>';
print_r($marca->getAttributes());//os dados antigos
$marca->update($request->all());
return $marca;

- Agora o PATCH em relação ao PUT não tem nenhuma diferença pois
os dois são utilizados para a mesma finalizada porém 
semanticamente é esperado que patch faz parte de pequenas 
atualizações não atualizações completas;
- Pegamos nosso exemplo seria ideal que utiliza-se apenas para 
alterar o nome, não todos os dados;
_________________________________________________________________
Removendo registros via DELETE

- Também é necessario que você passe o parametro na url;
 
$marca->delete($marca);
return ['msg'=>'A marca foi deletado'];
_________________________________________________________________
Extra - Entendendo o conceito de endpoint (URL, URN e URI)

- URL -> Host onde esta o recurso
jorgesantana.com
google.com

- URN -> Recurso dentro do host

/api/vagas
/curso/curso-completo-do-desencolvedor-laravel

- URI -> Combinação do protocolo + URL + URN
https://udemy.com/curso/curso-completo-do-desencolvedor-laravel
https://jorgesantana.com/api/vagas
_________________________________________________________________
Injetando a instância do Model no Controller e como lidar com 
o Type Hinting

- Estamos basicamento manipulando nossos model atraves de dois 
jeito um sendo estatico e outro seugestão do tipo 
- No estatico não estamos intanciando objetos estamos apenas 
utilizando uma função interna;
- Já no sugestão de tipo precisamos estanciar o objeto ou muitas
vezes o laravel já realiza issso para você e você só precisa 
chama-lo;
- Tmabém é possivel realizar isso com um outro metodo no caso 
sendo injeção do model que no caso instaciamos ele no construtor
do nosso controller;

protected $marca;

    public function __construct(Marca $marca)
    {
        $this->marca = $marca;
    }
----------------------------------------------
public function index()
    {
        //$marcas = Marca::all();
        $marca = $this->marca->all();
        return $marca;
    }
-----------------------------------------------
public function store(Request $request)
    {
        //$marca = Marca::create($request->all());
        $marca = $this->marca->create($request->all());
        return $marca;
    }
-----------------------------------------------
public function show( $id)
    {
        $marca = $this->marca->find($id);
        return $marca;
    }
-----------------------------------------------
public function update(Request $request, $id)
    {
        // print_r($request->all());//os dados atualizados
        // echo '<hr>';
        // print_r($marca->getAttributes());//os dados antigos

        $marca = $this->marca->find($id);
        $marca->update($request->all());
        return $marca;
    }
-----------------------------------------------
public function destroy($id)
    {
       $marca = $this->marca->find($id);
       $marca->delete();
       return ['msg'=>'A marca foi deletado'];
    }
_________________________________________________________________
Validações parte 1 - Controle de fluxos

- Vamos focar por enquanto no show, update e destrpy, caso eles 
não tenham recurso retornar json com mensagem de indiponivel

public function destroy($id)
    {
       $marca = $this->marca->find($id);
       if ($marca === null) {
        return ['erro'=>'Recurso indisponivel - (Exclusão)'];
    }
       $marca->delete();
       return ['msg'=>'A marca foi removida'];
    }
_________________________________________________________________
Validações parte 2 - Status Code HTTP

- Status code e como podemos aplicalos dentro da nossa api.
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
- Esse link tem como objetivo mostrar todo os status code do 
protocolo HTTP;
- Perceba que o Status Code é muito importante porque estamos 
fazendo uma requisição de caso ele não encontre o valor ele 
retorna;


return ['erro'=>'Recurso indisponivel - (Atualização)'];


- Porém se olharmos para o Status code ele vai indicar status 
200 que é um status de sucesso na resposta porém não foi 
encontrado oque vc queria;
- Com isso o mais indicado é vc modificar a nomenclatura 
indicando o erro real e não o status code errado para aquela 
resposta da requisição;


return response()->json(['erro'=>'Recurso indisponivel - 
(ver id)'], 404);

- No caso do store também adicionamos ;

$marca = $this->marca->create($request->all());
return response()->json($marca, 201);

- Teste no seu POSTMAN essas validações que fizemos e veja como
é importante cada validação;
_________________________________________________________________
Validações parte 3 - Validando parâmetros e a importância do 
Accept

- Iremos tratar o metodo store de como em que caso o parametro 
não seja válido retorna um json com as mensagens de feedback(s);


//tratar nome e imagem
 $regras = ['nome' => 'required|unique:marcas',
        'imagem'=> 'required'
    ];
 $feedback = [
        'required'=> 'O campo :attribute é obrigatório.',
        'nome.unique' => 'O nome da marca já existe.'
    ];
  $request ->validate($regras, $feedback);


- Para essa validação acontecer e não encaminhar o cliente de 
volta uma página inicial como o validade trabalha o ideal é vc no 
header do postman colocar o Accept pois vc esta dizendo que esse 
cliente consegue trabalhar com arquivos json;
_________________________________________________________________
Implementando as regras de validação (Rules) no Model

- A regra que criamos anteriormente funciona porém ela fica muito
sucetivel a erro, um exemplo disso e caso marca receba um 
atributo isso já pode gerar um problema para nós futuramente;
- Então o ideal é você colocar esse tipo de validação dentro do 
model marca por uma vez que alterado isso implica em tudo de 
uma vez;
- Criamos 2 metodos dentro da model;

public function rules() {
        return [
        'nome' => 'required|unique:marcas',
        'imagem'=> 'required'
    ];

    }
    public function feedback(){
        return [
        'required'=> 'O campo :attribute é obrigatório.',
        'nome.unique' => 'O nome da marca já existe.'
        ];
    }

- Em seguida no Controller adicionamos;

$request ->validate($this->marca->rules(),$this->marca->feedback());

- Estamos validando a requisição onde atraves da model marca 
estamos chamando o metodo rules e feedback para realizar essa
validação;
_________________________________________________________________
Validações parte 4 - Regras de validação no Update - Lidando 
com o Unique

- A validação unique lea tem três parametros;

1- tabela;
2- nome da coluna que será pesquisda na tabela;
3- id do registro que sera desconsiderado na pesquisa;

'nome' => 'required|unique:marcas,nome,'.$this->id.'|min:3',

- No caso fizemos uma validação no controller de modo em que todo
update vai precisar acessar o usuario que já existe e realizar 
uma alteração em algo. Resumindo, essa validação assegura que o 
campo nome seja obrigatório, único na tabela marcas (com exceção 
do registro atual durante a atualização) e tenha pelo menos 3 
caracteres de comprimento;
_________________________________________________________________
Validações parte 5 - Regras de validação no Update - Lidando 
com o PUT/PATCH

- Criamos dentro do update uma validação capaz de aceitar tanto
o PATCH quanto o PUT
- No controller 

}
        if($request->method() === 'PATCH'){

            $regrasDinamicas =array();

            //percorrendo todas as regras definidas no modo
            foreach($marca->rules() as $input => $regra){

                //coletar apenas as regras aplicasveis aos paramêtros parciais da requisição PATCH
                if (array_key_exists($input, $request->all())) {
                    $regrasDinamicas[$input] = $regra;
                }
            }

            $request->validate($regrasDinamicas, $marca->feedback());
        }

        else{
        $request->validate($marca->rules(), $marca->feedback());
        }

        $marca->update($request->all());
        return response()->json($marca, 200);
    }
_________________________________________________________________
Upload de arquivos - Implementando o upload de imagens parte 1

- Como realizar upload de arquivos no caso vamos utilizar upload
de imagem mas pode ser usado para vídeo, som e etc ...
- Agora dentro do post vamos trabalhar com outro parametro no 
body vamos trabalhar com form_data iremos por enquando dizer que
nosso cliente sabe trabalhar com arquivos json e utilizaremos
o metodo post (store).
- Podemos acessar os arquivos texte e file dessa forma;

       //dd($request->nome);
       //dd($request->get('nome'));


       //dd($request->file('imagem'));
       //dd($request->imagem);
_________________________________________________________________
Upload de arquivos - Implementando o upload de imagens parte 2

- Para realizar o upload de um arquivo precisamos passar dois 
parametros para ele um é o caminho e outro o disco é onde ele vai
ficar;

	$image = $request -> file('imagem');
        //$image ->store('path','disco');
	$image ->store('imagens', 'local');

- Por padrão vem no disco local do nossa aplicação mas se 
quisermos também podemos definir para ser baixadas na pasta 
public e etc..
_________________________________________________________________
Upload de arquivos - Implementando o upload de imagens parte 3

- Chegou a hora de implementarmos a lógica para recuperamos o 
nome eo patch de onde está esse arquivo para conseguirmoa acessar;
- Também vamos tratar o tipo de arquivo recebido;
- Na model;

'imagem' => 'required|file|mimes:png';

- Adicionamos file e mimes e em seguida podemos adicionar arquivos
de diversas extensões como xlss, ppt, pdf, jpeg, mp3, mp4;

- No Controller;

 $imagem = $request -> file('imagem');
       $imagem_urn = $imagem ->store('imagens', 'public');

       $marca =$this->marca->create([
        'nome' => $request->nome,
        'imagem' => $imagem_urn
       ]);
_________________________________________________________________
Upload de arquivos - Criando um link simbólico para o disco 
public

- Iremos criar um link simbolico para /public pois ele é o unico
diretorio publico dentro do laravel;

php artisan storage:link 
ou 
php artisan storage:link --force

- Em seu terminal coloque esse comando e ele será responsável 
por gerar um link desse tipo que precisamos;
- Lembre-se esse diretorio trabalha em conjunto com storage/app
/public/imagens caso vc exclua algo em um no outro também 
ocorrerá e isso é para tudo;
- Com isso craido eu consigo acessar essas imagens atraves de 
uma requisição get por exemplo;
- Coloque ele link no seu POSTMAN com o metodo get, lembre-se 
colocar o direcionamento de uma imagem válida do seu sistema;

localhost:8000/storage/imagens/6w1e44KVT0CwuPBB6cBGsZbQSW7y
QRKTr0qifEQ5.png
_________________________________________________________________
Upload de arquivos - Atualizando imagens

- Para ser possível atualizar o arquivo com imagem temos que 
utilizar um _metodo com pararmetro put ou patch no nosso POSTMAN
dessa forma; 

_method na key
put no value

- Assim como nome e bmw;
- Isso é um alimitação do framework laravel por isso temos que 
fazer isso;
_________________________________________________________________
Upload de arquivos - Removendo imagens

- Teremos a remoção da imagem em dois momentos, um momento quando 
atualizarmos teremos que remover a imagem antiga, e quando for 
feito o delete;
- Para realizar essa exclusão montamos uma condição para isso no 
update;

if ($request->file('imagem')) {
        Storage::disk('public')->delete($marca->imagem);
    }

- Onde vai a requisição de arquivos do tipo imagem vai até public
e exclui da marca a imagem já existente para a adição da nova;
- Agora no destroy;

  Storage::disk('public')->delete($marca->imagem);
________________________________________________________________
API WebService Rest para o Resource Modelo

- Estamos instanciando o metodo rules na model modelo e 
adicionando novos atributos;

public function rules()
    {
        return [
            'marca_id' =>'exists:marcas,id',
            'nome' => 'required|unique:modleos,nome,' . $this->id . '|min:3',
            'imagem' => 'required|file|mimes:png, jpg,jpeg',
            'numero_portas'=> 'required|integer|digits_between:1,5',//1 a 5
            'lugares'=> 'required|integer|digits_between:1,20',//1 a 20
            'air_bag'=>'required|boolean',
            'abs'=>'required|boolean' // true, flase, 1, 0, '1', '0'
        ];
    }

- Em seguida no controller iremos colocar a lógica de todos os 
metodos que temos como index, store, show, update e destroy;
- Basicamente é a mesma lócia do controller marca claro que com
as mudanças de chama do construtor modelo os atributos dele, 
acresido de uma nova pasta para $imagem_urn;

$imagem_urn = $imagem ->store('imagens/modelos', 'public');

- No metdod update e store;
_________________________________________________________________
Testando os endpoints de modelo

- Caso esteja com algum erro olhe na model modelos em rules em 
nome provavelmente a palavra modelos pode estar errada, e logo 
a cima também em protected $fillable a palavra imagens;
- Testamos com sucesso a aplicação dos metodos na pratica e com
isso foi constado que apenas o metodo PATCH precisa ser revisto
uma vez que não esta de acordo com o ModeloController mais;
_________________________________________________________________
Adicionando o relacionamento entre modelos e marcas

- Para adicionar o relacionamneto é bem simples criamos dois 
metodos um em cada model sendo ela marca e modelo instaciando 
nelas que uma marca tem diversos modelo e um modelo tem uma marca;
- Em modelocontroller foi adicionado uma expressão de 
relacionamento da controler modelo para com marca no metodo 
store da seguinte forma;

$modelo = $this->modelo->with('marca')->find($id);

- Sendo a expressão with('marca');
- No metodo index também adicionamos um with() pois quando 
pesquisarmos por modelo iremos ter o retorno também da marca;

return response()->json( $this->modelo->with('marca')->get(), 200);

- Também foi preciso alterar o metodo que antes era all() e agora
passou a ser get() pois com o all() poderia gerar alguns erros no
nosso código por conta do funcionamento do all();
_________________________________________________________________
Refactoring do endpoint update de marca e modelo

- 